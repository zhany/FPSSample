// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: mmlogic.proto
// </auto-generated>
// Original file comments:
// Copyright 2018 Google LLC
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
#pragma warning disable 0414, 1591
#region Designer generated code

using grpc = global::Grpc.Core;

namespace Api {
  /// <summary>
  /// The MMLogic API provides utility functions for common MMF functionality, such
  /// as retreiving profiles and players from state storage, writing results to state storage,
  /// and exposing metrics and statistics.
  /// </summary>
  public static partial class MmLogic
  {
    static readonly string __ServiceName = "api.MmLogic";

    static readonly grpc::Marshaller<global::Api.GetProfileRequest> __Marshaller_api_GetProfileRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Api.GetProfileRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Api.GetProfileResponse> __Marshaller_api_GetProfileResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Api.GetProfileResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Api.CreateProposalRequest> __Marshaller_api_CreateProposalRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Api.CreateProposalRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Api.CreateProposalResponse> __Marshaller_api_CreateProposalResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Api.CreateProposalResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Api.GetPlayerPoolRequest> __Marshaller_api_GetPlayerPoolRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Api.GetPlayerPoolRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Api.GetPlayerPoolResponse> __Marshaller_api_GetPlayerPoolResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Api.GetPlayerPoolResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Api.GetAllIgnoredPlayersRequest> __Marshaller_api_GetAllIgnoredPlayersRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Api.GetAllIgnoredPlayersRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Api.GetAllIgnoredPlayersResponse> __Marshaller_api_GetAllIgnoredPlayersResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Api.GetAllIgnoredPlayersResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Api.ListIgnoredPlayersRequest> __Marshaller_api_ListIgnoredPlayersRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Api.ListIgnoredPlayersRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Api.ListIgnoredPlayersResponse> __Marshaller_api_ListIgnoredPlayersResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Api.ListIgnoredPlayersResponse.Parser.ParseFrom);

    static readonly grpc::Method<global::Api.GetProfileRequest, global::Api.GetProfileResponse> __Method_GetProfile = new grpc::Method<global::Api.GetProfileRequest, global::Api.GetProfileResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "GetProfile",
        __Marshaller_api_GetProfileRequest,
        __Marshaller_api_GetProfileResponse);

    static readonly grpc::Method<global::Api.CreateProposalRequest, global::Api.CreateProposalResponse> __Method_CreateProposal = new grpc::Method<global::Api.CreateProposalRequest, global::Api.CreateProposalResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "CreateProposal",
        __Marshaller_api_CreateProposalRequest,
        __Marshaller_api_CreateProposalResponse);

    static readonly grpc::Method<global::Api.GetPlayerPoolRequest, global::Api.GetPlayerPoolResponse> __Method_GetPlayerPool = new grpc::Method<global::Api.GetPlayerPoolRequest, global::Api.GetPlayerPoolResponse>(
        grpc::MethodType.ServerStreaming,
        __ServiceName,
        "GetPlayerPool",
        __Marshaller_api_GetPlayerPoolRequest,
        __Marshaller_api_GetPlayerPoolResponse);

    static readonly grpc::Method<global::Api.GetAllIgnoredPlayersRequest, global::Api.GetAllIgnoredPlayersResponse> __Method_GetAllIgnoredPlayers = new grpc::Method<global::Api.GetAllIgnoredPlayersRequest, global::Api.GetAllIgnoredPlayersResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "GetAllIgnoredPlayers",
        __Marshaller_api_GetAllIgnoredPlayersRequest,
        __Marshaller_api_GetAllIgnoredPlayersResponse);

    static readonly grpc::Method<global::Api.ListIgnoredPlayersRequest, global::Api.ListIgnoredPlayersResponse> __Method_ListIgnoredPlayers = new grpc::Method<global::Api.ListIgnoredPlayersRequest, global::Api.ListIgnoredPlayersResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ListIgnoredPlayers",
        __Marshaller_api_ListIgnoredPlayersRequest,
        __Marshaller_api_ListIgnoredPlayersResponse);

    /// <summary>Service descriptor</summary>
    public static global::Google.Protobuf.Reflection.ServiceDescriptor Descriptor
    {
      get { return global::Api.MmlogicReflection.Descriptor.Services[0]; }
    }

    /// <summary>Base class for server-side implementations of MmLogic</summary>
    public abstract partial class MmLogicBase
    {
      /// <summary>
      ///  Send GetProfile a match object with the ID field populated, it will return a
      ///  'filled' one.
      ///  Note: filters are assumed to have been checked for validity by the
      ///  backendapi  when accepting a profile
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Api.GetProfileResponse> GetProfile(global::Api.GetProfileRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// CreateProposal is called by MMFs that wish to write their results to
      /// a proposed MatchObject, that can be sent out the Backend API once it has
      /// been approved (by default, by the evaluator process).
      ///  - adds all players in all Rosters to the proposed player ignore list
      ///  - writes the proposed match to the provided key
      ///  - adds that key to the list of proposals to be considered
      /// INPUT: 
      ///  * TO RETURN A MATCHOBJECT AFTER A SUCCESSFUL MMF RUN
      ///    To create a match MatchObject message with these fields populated:
      ///      - id, set to the value of the MMF_PROPOSAL_ID env var
      ///      - properties
      ///      - error.  You must explicitly set this to an empty string if your MMF
      ///      - roster, with the playerIDs filled in the 'players' repeated field. 
      ///      - [optional] pools, set to the output from the 'GetPlayerPools' call,
      ///        will populate the pools with stats about how many players the filters
      ///        matched and how long the filters took to run, which will be sent out
      ///        the backend api along with your match results.
      ///        was successful.
      ///  * TO RETURN AN ERROR 
      ///    To report a failure or error, send a MatchObject message with these
      ///    these fields populated:
      ///      - id, set to the value of the MMF_ERROR_ID env var. 
      ///      - error, set to a string value describing the error your MMF encountered.
      ///      - [optional] properties, anything you put here is returned to the
      ///        backend along with your error.
      ///      - [optional] rosters, anything you put here is returned to the
      ///        backend along with your error.
      ///      - [optional] pools, set to the output from the 'GetPlayerPools' call,
      ///        will populate the pools with stats about how many players the filters
      ///        matched and how long the filters took to run, which will be sent out
      ///        the backend api along with your match results.
      /// OUTPUT: a Result message with a boolean success value and an error string
      /// if an error was encountered
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Api.CreateProposalResponse> CreateProposal(global::Api.CreateProposalRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Player listing and filtering functions
      ///
      /// RetrievePlayerPool gets the list of players that match every Filter in the
      /// PlayerPool, .excluding players in any configured ignore lists.  It
      /// combines the results, and returns the resulting player pool.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="responseStream">Used for sending responses back to the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>A task indicating completion of the handler.</returns>
      public virtual global::System.Threading.Tasks.Task GetPlayerPool(global::Api.GetPlayerPoolRequest request, grpc::IServerStreamWriter<global::Api.GetPlayerPoolResponse> responseStream, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// Ignore List functions
      ///
      /// IlInput is an empty message reserved for future use.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Api.GetAllIgnoredPlayersResponse> GetAllIgnoredPlayers(global::Api.GetAllIgnoredPlayersRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      /// ListIgnoredPlayers retrieves players from the ignore list specified in the
      /// config file under 'ignoreLists.proposed.name'.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Api.ListIgnoredPlayersResponse> ListIgnoredPlayers(global::Api.ListIgnoredPlayersRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

    }

    /// <summary>Client for MmLogic</summary>
    public partial class MmLogicClient : grpc::ClientBase<MmLogicClient>
    {
      /// <summary>Creates a new client for MmLogic</summary>
      /// <param name="channel">The channel to use to make remote calls.</param>
      public MmLogicClient(grpc::Channel channel) : base(channel)
      {
      }
      /// <summary>Creates a new client for MmLogic that uses a custom <c>CallInvoker</c>.</summary>
      /// <param name="callInvoker">The callInvoker to use to make remote calls.</param>
      public MmLogicClient(grpc::CallInvoker callInvoker) : base(callInvoker)
      {
      }
      /// <summary>Protected parameterless constructor to allow creation of test doubles.</summary>
      protected MmLogicClient() : base()
      {
      }
      /// <summary>Protected constructor to allow creation of configured clients.</summary>
      /// <param name="configuration">The client configuration.</param>
      protected MmLogicClient(ClientBaseConfiguration configuration) : base(configuration)
      {
      }

      /// <summary>
      ///  Send GetProfile a match object with the ID field populated, it will return a
      ///  'filled' one.
      ///  Note: filters are assumed to have been checked for validity by the
      ///  backendapi  when accepting a profile
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Api.GetProfileResponse GetProfile(global::Api.GetProfileRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetProfile(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///  Send GetProfile a match object with the ID field populated, it will return a
      ///  'filled' one.
      ///  Note: filters are assumed to have been checked for validity by the
      ///  backendapi  when accepting a profile
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Api.GetProfileResponse GetProfile(global::Api.GetProfileRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_GetProfile, null, options, request);
      }
      /// <summary>
      ///  Send GetProfile a match object with the ID field populated, it will return a
      ///  'filled' one.
      ///  Note: filters are assumed to have been checked for validity by the
      ///  backendapi  when accepting a profile
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Api.GetProfileResponse> GetProfileAsync(global::Api.GetProfileRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetProfileAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///  Send GetProfile a match object with the ID field populated, it will return a
      ///  'filled' one.
      ///  Note: filters are assumed to have been checked for validity by the
      ///  backendapi  when accepting a profile
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Api.GetProfileResponse> GetProfileAsync(global::Api.GetProfileRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_GetProfile, null, options, request);
      }
      /// <summary>
      /// CreateProposal is called by MMFs that wish to write their results to
      /// a proposed MatchObject, that can be sent out the Backend API once it has
      /// been approved (by default, by the evaluator process).
      ///  - adds all players in all Rosters to the proposed player ignore list
      ///  - writes the proposed match to the provided key
      ///  - adds that key to the list of proposals to be considered
      /// INPUT: 
      ///  * TO RETURN A MATCHOBJECT AFTER A SUCCESSFUL MMF RUN
      ///    To create a match MatchObject message with these fields populated:
      ///      - id, set to the value of the MMF_PROPOSAL_ID env var
      ///      - properties
      ///      - error.  You must explicitly set this to an empty string if your MMF
      ///      - roster, with the playerIDs filled in the 'players' repeated field. 
      ///      - [optional] pools, set to the output from the 'GetPlayerPools' call,
      ///        will populate the pools with stats about how many players the filters
      ///        matched and how long the filters took to run, which will be sent out
      ///        the backend api along with your match results.
      ///        was successful.
      ///  * TO RETURN AN ERROR 
      ///    To report a failure or error, send a MatchObject message with these
      ///    these fields populated:
      ///      - id, set to the value of the MMF_ERROR_ID env var. 
      ///      - error, set to a string value describing the error your MMF encountered.
      ///      - [optional] properties, anything you put here is returned to the
      ///        backend along with your error.
      ///      - [optional] rosters, anything you put here is returned to the
      ///        backend along with your error.
      ///      - [optional] pools, set to the output from the 'GetPlayerPools' call,
      ///        will populate the pools with stats about how many players the filters
      ///        matched and how long the filters took to run, which will be sent out
      ///        the backend api along with your match results.
      /// OUTPUT: a Result message with a boolean success value and an error string
      /// if an error was encountered
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Api.CreateProposalResponse CreateProposal(global::Api.CreateProposalRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CreateProposal(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// CreateProposal is called by MMFs that wish to write their results to
      /// a proposed MatchObject, that can be sent out the Backend API once it has
      /// been approved (by default, by the evaluator process).
      ///  - adds all players in all Rosters to the proposed player ignore list
      ///  - writes the proposed match to the provided key
      ///  - adds that key to the list of proposals to be considered
      /// INPUT: 
      ///  * TO RETURN A MATCHOBJECT AFTER A SUCCESSFUL MMF RUN
      ///    To create a match MatchObject message with these fields populated:
      ///      - id, set to the value of the MMF_PROPOSAL_ID env var
      ///      - properties
      ///      - error.  You must explicitly set this to an empty string if your MMF
      ///      - roster, with the playerIDs filled in the 'players' repeated field. 
      ///      - [optional] pools, set to the output from the 'GetPlayerPools' call,
      ///        will populate the pools with stats about how many players the filters
      ///        matched and how long the filters took to run, which will be sent out
      ///        the backend api along with your match results.
      ///        was successful.
      ///  * TO RETURN AN ERROR 
      ///    To report a failure or error, send a MatchObject message with these
      ///    these fields populated:
      ///      - id, set to the value of the MMF_ERROR_ID env var. 
      ///      - error, set to a string value describing the error your MMF encountered.
      ///      - [optional] properties, anything you put here is returned to the
      ///        backend along with your error.
      ///      - [optional] rosters, anything you put here is returned to the
      ///        backend along with your error.
      ///      - [optional] pools, set to the output from the 'GetPlayerPools' call,
      ///        will populate the pools with stats about how many players the filters
      ///        matched and how long the filters took to run, which will be sent out
      ///        the backend api along with your match results.
      /// OUTPUT: a Result message with a boolean success value and an error string
      /// if an error was encountered
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Api.CreateProposalResponse CreateProposal(global::Api.CreateProposalRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_CreateProposal, null, options, request);
      }
      /// <summary>
      /// CreateProposal is called by MMFs that wish to write their results to
      /// a proposed MatchObject, that can be sent out the Backend API once it has
      /// been approved (by default, by the evaluator process).
      ///  - adds all players in all Rosters to the proposed player ignore list
      ///  - writes the proposed match to the provided key
      ///  - adds that key to the list of proposals to be considered
      /// INPUT: 
      ///  * TO RETURN A MATCHOBJECT AFTER A SUCCESSFUL MMF RUN
      ///    To create a match MatchObject message with these fields populated:
      ///      - id, set to the value of the MMF_PROPOSAL_ID env var
      ///      - properties
      ///      - error.  You must explicitly set this to an empty string if your MMF
      ///      - roster, with the playerIDs filled in the 'players' repeated field. 
      ///      - [optional] pools, set to the output from the 'GetPlayerPools' call,
      ///        will populate the pools with stats about how many players the filters
      ///        matched and how long the filters took to run, which will be sent out
      ///        the backend api along with your match results.
      ///        was successful.
      ///  * TO RETURN AN ERROR 
      ///    To report a failure or error, send a MatchObject message with these
      ///    these fields populated:
      ///      - id, set to the value of the MMF_ERROR_ID env var. 
      ///      - error, set to a string value describing the error your MMF encountered.
      ///      - [optional] properties, anything you put here is returned to the
      ///        backend along with your error.
      ///      - [optional] rosters, anything you put here is returned to the
      ///        backend along with your error.
      ///      - [optional] pools, set to the output from the 'GetPlayerPools' call,
      ///        will populate the pools with stats about how many players the filters
      ///        matched and how long the filters took to run, which will be sent out
      ///        the backend api along with your match results.
      /// OUTPUT: a Result message with a boolean success value and an error string
      /// if an error was encountered
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Api.CreateProposalResponse> CreateProposalAsync(global::Api.CreateProposalRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CreateProposalAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// CreateProposal is called by MMFs that wish to write their results to
      /// a proposed MatchObject, that can be sent out the Backend API once it has
      /// been approved (by default, by the evaluator process).
      ///  - adds all players in all Rosters to the proposed player ignore list
      ///  - writes the proposed match to the provided key
      ///  - adds that key to the list of proposals to be considered
      /// INPUT: 
      ///  * TO RETURN A MATCHOBJECT AFTER A SUCCESSFUL MMF RUN
      ///    To create a match MatchObject message with these fields populated:
      ///      - id, set to the value of the MMF_PROPOSAL_ID env var
      ///      - properties
      ///      - error.  You must explicitly set this to an empty string if your MMF
      ///      - roster, with the playerIDs filled in the 'players' repeated field. 
      ///      - [optional] pools, set to the output from the 'GetPlayerPools' call,
      ///        will populate the pools with stats about how many players the filters
      ///        matched and how long the filters took to run, which will be sent out
      ///        the backend api along with your match results.
      ///        was successful.
      ///  * TO RETURN AN ERROR 
      ///    To report a failure or error, send a MatchObject message with these
      ///    these fields populated:
      ///      - id, set to the value of the MMF_ERROR_ID env var. 
      ///      - error, set to a string value describing the error your MMF encountered.
      ///      - [optional] properties, anything you put here is returned to the
      ///        backend along with your error.
      ///      - [optional] rosters, anything you put here is returned to the
      ///        backend along with your error.
      ///      - [optional] pools, set to the output from the 'GetPlayerPools' call,
      ///        will populate the pools with stats about how many players the filters
      ///        matched and how long the filters took to run, which will be sent out
      ///        the backend api along with your match results.
      /// OUTPUT: a Result message with a boolean success value and an error string
      /// if an error was encountered
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Api.CreateProposalResponse> CreateProposalAsync(global::Api.CreateProposalRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_CreateProposal, null, options, request);
      }
      /// <summary>
      /// Player listing and filtering functions
      ///
      /// RetrievePlayerPool gets the list of players that match every Filter in the
      /// PlayerPool, .excluding players in any configured ignore lists.  It
      /// combines the results, and returns the resulting player pool.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Api.GetPlayerPoolResponse> GetPlayerPool(global::Api.GetPlayerPoolRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetPlayerPool(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Player listing and filtering functions
      ///
      /// RetrievePlayerPool gets the list of players that match every Filter in the
      /// PlayerPool, .excluding players in any configured ignore lists.  It
      /// combines the results, and returns the resulting player pool.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Api.GetPlayerPoolResponse> GetPlayerPool(global::Api.GetPlayerPoolRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncServerStreamingCall(__Method_GetPlayerPool, null, options, request);
      }
      /// <summary>
      /// Ignore List functions
      ///
      /// IlInput is an empty message reserved for future use.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Api.GetAllIgnoredPlayersResponse GetAllIgnoredPlayers(global::Api.GetAllIgnoredPlayersRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetAllIgnoredPlayers(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Ignore List functions
      ///
      /// IlInput is an empty message reserved for future use.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Api.GetAllIgnoredPlayersResponse GetAllIgnoredPlayers(global::Api.GetAllIgnoredPlayersRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_GetAllIgnoredPlayers, null, options, request);
      }
      /// <summary>
      /// Ignore List functions
      ///
      /// IlInput is an empty message reserved for future use.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Api.GetAllIgnoredPlayersResponse> GetAllIgnoredPlayersAsync(global::Api.GetAllIgnoredPlayersRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetAllIgnoredPlayersAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// Ignore List functions
      ///
      /// IlInput is an empty message reserved for future use.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Api.GetAllIgnoredPlayersResponse> GetAllIgnoredPlayersAsync(global::Api.GetAllIgnoredPlayersRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_GetAllIgnoredPlayers, null, options, request);
      }
      /// <summary>
      /// ListIgnoredPlayers retrieves players from the ignore list specified in the
      /// config file under 'ignoreLists.proposed.name'.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Api.ListIgnoredPlayersResponse ListIgnoredPlayers(global::Api.ListIgnoredPlayersRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ListIgnoredPlayers(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// ListIgnoredPlayers retrieves players from the ignore list specified in the
      /// config file under 'ignoreLists.proposed.name'.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Api.ListIgnoredPlayersResponse ListIgnoredPlayers(global::Api.ListIgnoredPlayersRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ListIgnoredPlayers, null, options, request);
      }
      /// <summary>
      /// ListIgnoredPlayers retrieves players from the ignore list specified in the
      /// config file under 'ignoreLists.proposed.name'.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Api.ListIgnoredPlayersResponse> ListIgnoredPlayersAsync(global::Api.ListIgnoredPlayersRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ListIgnoredPlayersAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// ListIgnoredPlayers retrieves players from the ignore list specified in the
      /// config file under 'ignoreLists.proposed.name'.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Api.ListIgnoredPlayersResponse> ListIgnoredPlayersAsync(global::Api.ListIgnoredPlayersRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ListIgnoredPlayers, null, options, request);
      }
      /// <summary>Creates a new instance of client from given <c>ClientBaseConfiguration</c>.</summary>
      protected override MmLogicClient NewInstance(ClientBaseConfiguration configuration)
      {
        return new MmLogicClient(configuration);
      }
    }

    /// <summary>Creates service definition that can be registered with a server</summary>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    public static grpc::ServerServiceDefinition BindService(MmLogicBase serviceImpl)
    {
      return grpc::ServerServiceDefinition.CreateBuilder()
          .AddMethod(__Method_GetProfile, serviceImpl.GetProfile)
          .AddMethod(__Method_CreateProposal, serviceImpl.CreateProposal)
          .AddMethod(__Method_GetPlayerPool, serviceImpl.GetPlayerPool)
          .AddMethod(__Method_GetAllIgnoredPlayers, serviceImpl.GetAllIgnoredPlayers)
          .AddMethod(__Method_ListIgnoredPlayers, serviceImpl.ListIgnoredPlayers).Build();
    }

    /// <summary>Register service method implementations with a service binder. Useful when customizing the service binding logic.
    /// Note: this method is part of an experimental API that can change or be removed without any prior notice.</summary>
    /// <param name="serviceBinder">Service methods will be bound by calling <c>AddMethod</c> on this object.</param>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    public static void BindService(grpc::ServiceBinderBase serviceBinder, MmLogicBase serviceImpl)
    {
      serviceBinder.AddMethod(__Method_GetProfile, serviceImpl.GetProfile);
      serviceBinder.AddMethod(__Method_CreateProposal, serviceImpl.CreateProposal);
      serviceBinder.AddMethod(__Method_GetPlayerPool, serviceImpl.GetPlayerPool);
      serviceBinder.AddMethod(__Method_GetAllIgnoredPlayers, serviceImpl.GetAllIgnoredPlayers);
      serviceBinder.AddMethod(__Method_ListIgnoredPlayers, serviceImpl.ListIgnoredPlayers);
    }

  }
}
#endregion
